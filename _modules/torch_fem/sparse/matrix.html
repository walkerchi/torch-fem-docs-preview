<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>torch_fem.sparse.matrix &mdash; torch_fem  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/mytheme.css" type="text/css" />
    <link rel="shortcut icon" href="https://raw.githubusercontent.com/walkerchi/torch_fem_sphinx_theme/master/torch_fem_sphinx_theme/static/img/torch_fem_logo.webp"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="https://raw.githubusercontent.com/walkerchi/torch_fem_sphinx_theme/master/torch_fem_sphinx_theme/static/img/torch_fem_logo.webp" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Install Torch-FEM</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/introduction.html">Introduction by Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../get_started/benchmark.html">Benchmark</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/adjacency.html">Adjacency</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/poisson.html">Poisson Equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/wave.html">Wave Equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/linear_elasticity.html">Linear Elasticity</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/dataset.html">torch_fem.dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/mesh.html">torch_fem.mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/sparse.html">torch_fem.sparse</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/assemble.html">torch_fem.assemble</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/operator.html">torch_fem.operator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/ode.html">torch_fem.ode</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/functional.html">torch_fem.functional</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">torch_fem</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">torch_fem.sparse.matrix</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for torch_fem.sparse.matrix</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span> 
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">.mm</span> <span class="kn">import</span> <span class="n">spmm</span> 
<span class="kn">from</span> <span class="nn">.solve</span> <span class="kn">import</span> <span class="n">spsolve</span>


<div class="viewcode-block" id="SparseMatrix"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix">[docs]</a><span class="k">class</span> <span class="nc">SparseMatrix</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;coo format sparse matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    edata: torch.Tensor </span>
<span class="sd">        1D float tensor of shape :math:`[|\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the edge data</span>
<span class="sd">    row: torch.Tensor</span>
<span class="sd">        1D int tensor of shape :math:`[|\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the row indices</span>
<span class="sd">    col: torch.Tensor</span>
<span class="sd">        1D int tensor of shape :math:`[|\\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the column indices</span>
<span class="sd">    shape: Tuple[int, int]</span>
<span class="sd">        the shape of the sparse matrix of the first two dim, e.g. (3, 4)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    edata: torch.Tensor </span>
<span class="sd">        1D float tensor of shape :math:`[|\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the edge data</span>
<span class="sd">    row: torch.Tensor</span>
<span class="sd">        1D int tensor of shape :math:`[|\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the row indices</span>
<span class="sd">    col: torch.Tensor</span>
<span class="sd">        1D int tensor of shape :math:`[|\\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        the column indices</span>
<span class="sd">    shape: Tuple[int, int]</span>
<span class="sd">        the shape of the sparse matrix of the first two dim, e.g. (3, 4)</span>
<span class="sd">    hash_layout: str</span>
<span class="sd">        it will be used to check if two sparse matrices have the same layout,</span>
<span class="sd">        the hash of the layout of the sparse matrix</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edata</span><span class="p">,</span>  <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;the first dim of edata, row, col should be the same, but got </span><span class="si">{</span><span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">edata</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">row</span><span class="o">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;edata, row, col should be on the same device, but got </span><span class="si">{</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">device</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;edata&quot;</span><span class="p">,</span> <span class="n">edata</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">layout_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span> <span class="o">+</span> <span class="n">col</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the edge indices of shape :math:`[2, |\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="SparseMatrix.elementwise_operation"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.elementwise_operation">[docs]</a>    <span class="k">def</span> <span class="nf">elementwise_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elementwise operation with another sparse matrix or a tensor or a scalar</span>
<span class="sd">        If the object is a sparse matrix, the :attr:`edges` of the two sparse matrices should be the same</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        func: Callable[[torch.Tensor, torch.Tensor], torch.Tensor]</span>
<span class="sd">            the elementwise operation</span>
<span class="sd">        obj: SparseMatrix or torch.Tensor or int or float</span>
<span class="sd">            the object to be elementwise operated with</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: SparseMatrix</span>
<span class="sd">            the result of the elementwise operation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">SparseMatrix</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the shape of the two sparse matrices should be the same, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_same_layout</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the row indices of the two sparse matrices should be the same, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">row</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">edata</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the shape of the sparse matrix and the tensor should be the same, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2"> for SparseMatrix.elementwise_operation </span><span class="si">{</span><span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">obj</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elementwise_operation</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">pow</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: torch.Tensor</span>
<span class="sd">            the dense tensor of shape [b] or [b,h] to be multiplied with the sparse matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the result of the multiplication of shape [a] or [a,h]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spmm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="SparseMatrix.solve"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: torch.Tensor</span>
<span class="sd">            the dense tensor of shape [a] or [a,h] to be solved with the sparse matrix</span>
<span class="sd">        backend: str, optional</span>
<span class="sd">            the backend to solve the sparse matrix, can be :obj:`None`, :obj:`&quot;torch&quot;`, :obj:`&quot;scipy&quot;` </span>
<span class="sd">            or :obj:`&quot;torch_scipy&quot;`, default :obj:`None`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the result of the solution of shape [b] or [b,h]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;the first dim of x should be the same as the second dim of the sparse matrix, but got </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">spsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.requires_grad_"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.requires_grad_">[docs]</a>    <span class="k">def</span> <span class="nf">requires_grad_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        requires_grad: bool, optional</span>
<span class="sd">            whether the sparse matrix requires gradient, default :obj:`True`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseMatrix    </span>
<span class="sd">            the sparse matrix with requires_grad set to requires_grad</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="n">requires_grad</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
  
<div class="viewcode-block" id="SparseMatrix.transpose"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tranpose the sparse matrix</span>

<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            A = A^\\top</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SparseMatrix.sqrt"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.sqrt">[docs]</a>    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;element-wise square root</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>

<span class="sd">            A_{ij} = \\sqrt{A_{ij}}</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.reciprocal"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.reciprocal">[docs]</a>    <span class="k">def</span> <span class="nf">reciprocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;element-wise reciprocal</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            A_{ij} = \\frac{1}{A_{ij}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.degree"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.degree">[docs]</a>    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;how many non-zero element in each row/column</span>
<span class="sd">        - axis = :obj:`0`</span>
<span class="sd">            </span>
<span class="sd">            .. math::</span>
<span class="sd">                \\sum_{j}\mathbb{1}_{A_{ij} \\neq 0}    </span>
<span class="sd">        </span>
<span class="sd">        - axis = :obj:`1`</span>
<span class="sd">        </span>
<span class="sd">            .. math::</span>
<span class="sd">                \\sum_{i}\mathbb{1}_{A_{ij} \\neq 0}     </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis: int, optional</span>
<span class="sd">            the axis to sum, can be :obj:`0` or :obj:`1`, default :obj:`0`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the degree of shape :math:`[n_{\\text{row}}]` or :math:`[n_{\\text{col}}]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SparseMatrix.sum"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sum of all non-zero elements</span>

<span class="sd">        * axis = :obj:`None`</span>

<span class="sd">            .. math::</span>
<span class="sd">                \sum_{ij}A_{ij}</span>

<span class="sd">        * axis = :obj:`0`</span>

<span class="sd">            .. math::</span>
<span class="sd">                \sum_{j}A_{ij}</span>
<span class="sd">        </span>
<span class="sd">        * axis = :obj:`1`</span>
<span class="sd">        </span>
<span class="sd">            .. math::</span>
<span class="sd">                \sum_{i}A_{ij}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis: int, optional</span>
<span class="sd">            the axis to sum, can be :obj:`None`, :obj:`0` or :obj:`1`, default :obj:`None`</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the sum of shape :math:`[]` or :math:`[n_\\text{row}]` or :math:`[n_\\text{col}]`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> for SparseMatrix.sum&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.clone"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The cloned sparse matrix will share clone gradient with the original sparse matrix</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the cloned sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>
    
    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The detached sparse matrix will not share gradient with the original sparse matrix</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the detached sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;SparseMatrix(</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    edata: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    row  : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    col  : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;    shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad_fn</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad_fn</span><span class="w"> </span><span class="ow">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="kc">None</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span> 
            <span class="sa">f</span><span class="s2">&quot;)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the transpose of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requires_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            whether the sparse matrix requires gradient or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">requires_grad</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.dtype</span>
<span class="sd">            the dtype of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">dtype</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.device</span>
<span class="sd">            the device of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        ------- </span>
<span class="sd">        torch_fem.sparse.SparseMatrix or None</span>
<span class="sd">            if the sparse matrix requires gradient, return the grad for each element </span>
<span class="sd">            of the sparse matrix, otherwise return :obj:`None`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grad_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.autograd.Function or None</span>
<span class="sd">            if the sparse matrix requires gradient, return the grad_fn for each element </span>
<span class="sd">            of the sparse matrix, otherwise return :obj:`None`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">grad_fn</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            the number of non-zero elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">layout_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the mask of the layout, where the non-zero elements are 1, otherwise 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">mask</span>

<div class="viewcode-block" id="SparseMatrix.type"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.type">[docs]</a>    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix with dtype set to dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">to_</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="SparseMatrix.detach"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix with requires_grad set to False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.to_scipy_coo"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.to_scipy_coo">[docs]</a>    <span class="k">def</span> <span class="nf">to_scipy_coo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.sparse.coo_matrix</span>
<span class="sd">            the scipy.sparse.coo_matrix of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.to_sparse_coo"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.to_sparse_coo">[docs]</a>    <span class="k">def</span> <span class="nf">to_sparse_coo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Turn the sparse matrix into a torch.sparse_coo_tensor, the gradient will be lost</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.sparse_coo_tensor</span>
<span class="sd">            the torch.sparse_coo_tensor of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sparse_coo_tensor</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.to_dense"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.to_dense">[docs]</a>    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Turn the sparse matrix into a dense matrix, the gradient will be maintained</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch.Tensor</span>
<span class="sd">            the dense tensor of the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">matrix</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span>
        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="SparseMatrix.has_same_layout"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.has_same_layout">[docs]</a>    <span class="k">def</span> <span class="nf">has_same_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj: SparseMatrix or str</span>
<span class="sd">            the object to be compared with, if it is a str, it will be compared with the layout_hash of the sparse matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            whether the two sparse matrices have the same layout</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">SparseMatrix</span><span class="p">,</span><span class="nb">str</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;matrix must be SparseMatrix or str, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout_hash</span> <span class="o">==</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layout_hash</span> <span class="o">==</span> <span class="n">obj</span><span class="o">.</span><span class="n">layout_hash</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_scipy_coo</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">row</span>   <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">col</span>   <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="SparseMatrix.from_sparse_coo"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.from_sparse_coo">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_sparse_coo</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrix: torch.sparse_coo_tensor</span>
<span class="sd">            the sparse matrix to be converted</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix converted from the torch.sparse_coo_tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">row</span>   <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">col</span>   <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">indices</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.from_block_coo"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.from_block_coo">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_block_coo</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Each element in a sparse matrix is a block matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edata: torch.Tensor </span>
<span class="sd">            3D float tensor of shape :math:`[|\\mathcal E|, C, C]`, where :math:`|\mathcal E|` is the number of edges, :math:`C` is the size of the block data</span>
<span class="sd">            the block data</span>
<span class="sd">        row: torch.Tensor </span>
<span class="sd">            1D int tensor of shape :math:`[|\\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">            the row indices</span>
<span class="sd">        col: torch.Tensor </span>
<span class="sd">            1D int tensor of shape :math:`[|\\mathcal E|]`, where :math:`|\mathcal E|` is the number of edges</span>
<span class="sd">            the column indices</span>
<span class="sd">        shape: Tuple[int, int]</span>
<span class="sd">            the shape of the sparse matrix of the first two dim</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix converted from the block coo format of shape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_edges</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">row</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">col</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_edges</span><span class="p">,),</span> <span class="sa">f</span><span class="s2">&quot;the shape of row and col should be </span><span class="si">{</span><span class="n">n_edges</span><span class="si">}</span><span class="s2">, but got </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">col</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="n">edata</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_edges</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">block_size</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;the shape of edata should be </span><span class="si">{</span><span class="n">n_edges</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="p">,</span><span class="w"> </span><span class="n">block_size</span><span class="si">}</span><span class="s2">, but got </span><span class="si">{</span><span class="n">edata</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">edata</span> <span class="o">=</span> <span class="n">edata</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">row</span>   <span class="o">=</span> <span class="n">row</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">)</span>
        <span class="n">col</span>   <span class="o">=</span> <span class="n">col</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">)</span>

        <span class="n">i</span><span class="p">,</span><span class="n">j</span>   <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">))</span> 
       
        <span class="n">row</span>   <span class="o">=</span> <span class="n">row</span> <span class="o">*</span> <span class="n">block_size</span><span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">col</span>   <span class="o">=</span> <span class="n">col</span> <span class="o">*</span> <span class="n">block_size</span><span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">block_size</span><span class="p">)</span>
        <span class="n">row</span>   <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">col</span>   <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.from_dense"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.from_dense">[docs]</a>    <span class="nd">@staticmethod</span> 
    <span class="k">def</span> <span class="nf">from_dense</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor: torch.Tensor</span>
<span class="sd">            the dense tensor to be converted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix converted from the dense tensor</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix.from_dense(torch.eye(3))</span>
<span class="sd">        SparseMatrix(</span>
<span class="sd">            edata: tensor([1., 1., 1.])</span>
<span class="sd">            row  : tensor([0, 1, 2])</span>
<span class="sd">            col  : tensor([0, 1, 2])</span>
<span class="sd">            shape: (3, 3)</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the tensor should be 2D, but got </span><span class="si">{</span><span class="n">tensor</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tensor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.random"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.random">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;randomly generate a sparse matrix</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m: int</span>
<span class="sd">            the number of rows</span>
<span class="sd">        n: int</span>
<span class="sd">            the number of cols</span>
<span class="sd">        density: float, optional</span>
<span class="sd">            the density of the sparse matrix, default 0.1</span>
<span class="sd">        device: str, optional</span>
<span class="sd">            the device of the sparse matrix, default cpu</span>
<span class="sd">        dtype: torch.dtype, optional</span>
<span class="sd">            the dtype of the sparse matrix, default torch.float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix of shape :math:`[m,n]` with density :obj:`density` and dtype :obj:`dtype`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;coo&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">from_scipy_coo</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.random_layout"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.random_layout">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">random_layout</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;randomly generate a sparse matrix layout</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m: int</span>
<span class="sd">            the number of rows</span>
<span class="sd">        n: int</span>
<span class="sd">            the number of cols</span>
<span class="sd">        density: float, optional</span>
<span class="sd">            the density of the sparse matrix, default 0.1</span>
<span class="sd">        device: str, optional</span>
<span class="sd">            the device of the sparse matrix, default cpu</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[torch.Tensor, torch.Tensor, Tuple[int, int]]</span>
<span class="sd">            the layout of the sparse matrix of shape :math:`[m,n]` with density :obj:`density` and dtype :obj:`dtype`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;coo&quot;</span><span class="p">)</span>
        <span class="n">row</span>    <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">col</span>    <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">shape</span>  <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span></div>
    
<div class="viewcode-block" id="SparseMatrix.random_from_layout"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.random_from_layout">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">random_from_layout</span><span class="p">(</span><span class="n">layout</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;randomly generate a sparse matrix from a layout</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        layout: Tuple[torch.Tensor, torch.Tensor, Tuple[int, int]]</span>
<span class="sd">            the layout of the sparse matrix</span>
<span class="sd">        device: str, optional</span>
<span class="sd">            the device of the sparse matrix, default cpu</span>
<span class="sd">        dtype: torch.dtype, optional</span>
<span class="sd">            the dtype of the sparse matrix, default torch.float</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix of shape :math:`[m,n]` with density :obj:`density` and dtype :obj:`dtype`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">layout</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">col</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.eye"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.eye">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;generate a sparse identity matrix</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n: int</span>
<span class="sd">            the number of rows and columns</span>
<span class="sd">        value: float, optional</span>
<span class="sd">            the value of the diagonal elements, default 1.</span>
<span class="sd">        device: str, optional</span>
<span class="sd">            the device of the sparse matrix, default cpu</span>
<span class="sd">        dtype: torch.dtype, optional</span>
<span class="sd">            the dtype of the sparse matrix, default torch.float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the sparse matrix of shape :math:`[n,n]` with value :obj:`value` and dtype :obj:`dtype`</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix.eye(3).to_dense()</span>
<span class="sd">        tensor([[1., 0., 0.],</span>
<span class="sd">                [0., 1., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="p">,</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span>
            <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SparseMatrix.full"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.full">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;generate a dense matrix filled with a value</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m: int </span>
<span class="sd">            the number of rows</span>
<span class="sd">        n: int</span>
<span class="sd">            the number of columns</span>
<span class="sd">        value: float, optional</span>
<span class="sd">            the value of the diagonal elements, default 1.</span>
<span class="sd">        device: str, optional</span>
<span class="sd">            the device of the sparse matrix, default cpu</span>
<span class="sd">        dtype: torch.dtype, optional</span>
<span class="sd">            the dtype of the sparse matrix, default torch.float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the dense tensor of shape :math:`[n,n]` with value :obj:`value` and dtype :obj:`dtype`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span>
        <span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">rows</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">cols</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="SparseMatrix.combine_vector"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.combine_vector">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_vector</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Combine sparse matrices into a sparse matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrices: List[torch_fem.sparse.SparseMatrix]</span>
<span class="sd">            the sparse matrices to be combined</span>
<span class="sd">        axis: int, optional</span>
<span class="sd">            the axis to combine, can be :obj:`0` or :obj:`1`, default :obj:`0`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the combined sparse matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix.combine_vector([</span>
<span class="sd">        ...     SparseMatrix.eye(3), SparseMatrix.eye(3)    </span>
<span class="sd">        ... ]).to_dense()</span>
<span class="sd">        tensor([[1., 0., 0.],</span>
<span class="sd">                [0., 1., 0.],</span>
<span class="sd">                [0., 0., 1.],</span>
<span class="sd">                [1., 0., 0.],</span>
<span class="sd">                [0., 1., 0.],</span>
<span class="sd">                [0., 0., 1.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sparse_matrix</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">,</span> <span class="p">(</span><span class="n">SparseMatrix</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;the sparse matrices should be SparseMatrix, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">axis</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;the shape of the sparse matrices should be the same, but got </span><span class="si">{</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">sparse_matrix</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">col_offset</span><span class="p">)</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">row_offset</span><span class="p">)</span>
            <span class="n">edata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sparse_matrix</span><span class="o">.</span><span class="n">edata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">col_offset</span> <span class="o">+=</span> <span class="n">sparse_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> for SparseMatrix.combine_vector, could only be 0 or 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_offset</span> <span class="o">+=</span> <span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="n">col_offset</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.combine_matrix"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.combine_matrix">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine_matrix</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrices: List[List[torch_fem.sparse.SparseMatrix or None or float or int]]</span>
<span class="sd">            the sparse matrices to be combined</span>
<span class="sd">        axis: int, optional</span>
<span class="sd">            the axis to combine, can be :obj:`0` or :obj:`1`, default :obj:`0`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the combined sparse matrix</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; SparseMatrix.combine_matrix([</span>
<span class="sd">        ...     [SparseMatrix.eye(3), SparseMatrix.eye(3)],</span>
<span class="sd">        ...     [SparseMatrix.eye(3), SparseMatrix.eye(3)]</span>
<span class="sd">        ... ]).to_dense()</span>
<span class="sd">        tensor([[1., 0., 0., 1., 0., 0.],</span>
<span class="sd">                [0., 1., 0., 0., 1., 0.],</span>
<span class="sd">                [0., 0., 1., 0., 0., 1.],</span>
<span class="sd">                [1., 0., 0., 1., 0., 0.],</span>
<span class="sd">                [0., 1., 0., 0., 1., 0.],</span>
<span class="sd">                [0., 0., 1., 0., 0., 1.]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row_offset</span> <span class="o">=</span> <span class="mi">0</span> 
        <span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rows</span>       <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cols</span>       <span class="o">=</span> <span class="p">[]</span>
        <span class="n">edata</span>      <span class="o">=</span> <span class="p">[]</span>

        <span class="n">n_block_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">)</span>
        <span class="n">n_block_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">shape</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_block_rows</span><span class="p">,</span> <span class="n">n_block_cols</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="c1"># check numebr of blocks consistency</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_block_rows</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="sa">f</span><span class="s2">&quot;the number of columns of the sparse matrices should be the same, but got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_block_cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],(</span><span class="n">SparseMatrix</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)):</span>
                    <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># check shape inference</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">shape</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;there should be at least one non-zero sparse matrix in each row, but got dimension collapse at row </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">shape</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">shape</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="sa">f</span><span class="s2">&quot;there should be at least one non-zero sparse matrix in each column, but got dimension collapse at column </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">shape</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># check shape unique</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_block_rows</span><span class="p">):</span>
            <span class="n">nz_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">uni_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nz_shape</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">uni_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the number of rows of the sparse matrices should be the same, but got </span><span class="si">{</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">:,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> at row </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">uni_shape</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_block_cols</span><span class="p">):</span>
            <span class="n">nz_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">][</span><span class="n">shape</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">uni_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nz_shape</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">uni_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;the number of columns of the sparse matrices should be the same, but got </span><span class="si">{</span><span class="n">shape</span><span class="p">[:,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> at column </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">shape</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">][</span><span class="n">shape</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">uni_shape</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">)):</span>
            <span class="n">col_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                        <span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                        <span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">edata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">edata</span><span class="p">)</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="n">row_offset</span><span class="p">)</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="n">col_offset</span><span class="p">)</span>
                <span class="n">col_offset</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">row_offset</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">SparseMatrix</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">edata</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">(</span><span class="n">row_offset</span><span class="p">,</span> <span class="n">col_offset</span><span class="p">)</span>
        <span class="p">)</span></div>
    
<div class="viewcode-block" id="SparseMatrix.combine"><a class="viewcode-back" href="../../../api_reference/sparse.html#torch_fem.sparse.SparseMatrix.combine">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">matrices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the dispatch function for :attr:combine_vector and :attr:combine_matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        matrices: List[torch_fem.sparse.SparseMatrix or List[torch_fem.sparse.SparseMatrix or None or float or int]]</span>
<span class="sd">            the sparse matrices to be combined</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        torch_fem.sparse.SparseMatrix</span>
<span class="sd">            the combined sparse matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">combine_matrix</span><span class="p">(</span><span class="n">matrices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SparseMatrix</span><span class="o">.</span><span class="n">combine_vector</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, walkerchi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>